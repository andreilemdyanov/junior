package ru.job4j.threads;

/**
 * Class StopThread.
 *
 * @author Andrey Lemdyanov {lemdyanov5@mail.ru)
 * @version $Id$
 * @since 08.08.2017
 */
public class StopThread {
    /**
     * Точка входа.
     *
     * @param args массив строк.
     */
    public static void main(String[] args) {
        Thread timeThread = new Thread(new Time(100));
        String str = "Вы можете использовать коллективный механизм прерывания, обеспечиваемый платформой Java для конструирования гибких алгоритмов отмены. Функции (activities) могут решать, являются ли они отменяемыми или нет, насколько им следует быть восприимчивыми к прерыванию, и они могут задержать прерывание для выполнения специализированной очистки, если немедленный возврат подвергнет риску целостность приложения. Даже если вы захотите полностью проигнорировать прерывание в вашем коде, убедитесь в восстановлении статуса прерывания, если вы перехватили InterruptedException, и не генерируйте его повторно, чтобы вызывающий его код не был лишен информации о том, что произошло прерывание. Вы можете использовать коллективный механизм прерывания, обеспечиваемый платформой Java для конструирования гибких алгоритмов отмены. Функции (activities) могут решать, являются ли они отменяемыми или нет, насколько им следует быть восприимчивыми к прерыванию, и они могут задержать прерывание для выполнения специализированной очистки, если немедленный возврат подвергнет риску целостность приложения. Даже если вы захотите полностью проигнорировать прерывание в вашем коде, убедитесь в восстановлении статуса прерывания, если вы перехватили InterruptedException, и не генерируйте его повторно, чтобы вызывающий его код не был лишен информации о том, что произошло прерывание. Вы можете использовать коллективный механизм прерывания, обеспечиваемый платформой Java для конструирования гибких алгоритмов отмены. Функции (activities) могут решать, являются ли они отменяемыми или нет, насколько им следует быть восприимчивыми к прерыванию, и они могут задержать прерывание для выполнения специализированной очистки, если немедленный возврат подвергнет риску целостность приложения. Даже если вы захотите полностью проигнорировать прерывание в вашем коде, убедитесь в восстановлении статуса прерывания, если вы перехватили InterruptedException, и не генерируйте его повторно, чтобы вызывающий его код не был лишен информации о том, что произошло прерывание. В Java предусмотрен механизм, позволяющий одному потоку ждать завершения выполнения другого. Для этого используется метод join(). Например, чтобы главный поток подождал завершения побочного потока myThready, необходимо выполнить инструкцию myThready.join() в главном потоке. Как только поток myThready завершится, метод join() вернет управление, и главный поток сможет продолжить выполнение.";
        Thread countThread = new Thread(new CountChar(str));
        timeThread.start();
        countThread.start();

        try {
            timeThread.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        countThread.interrupt();
    }
}


